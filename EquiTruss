
import breeze.linalg.min
import org.apache.spark.graphx._
import org.apache.spark.rdd.RDD
import org.apache.spark.{SparkConf, SparkContext}
import org.apache.spark.graphx.EdgeDirection
import org.apache.spark.util.collection.OpenHashSet
import org.apache.spark._
import org.apache.spark.util.collection.{BitSet, OpenHashSet}
import org.apache.spark.rdd.RDD
import scala.collection.immutable.IntMap
import org.apache.spark.storage.StorageLevel
import scala.collection.mutable
import scala.collection.mutable.ListBuffer
import scala.collection.mutable.Map
import scala.reflect.ClassTag
import scala.math._
import scala.reflect.ClassTag
import org.apache.spark.sql.SQLImplicits
import org.apache.spark.sql._
import org.graphframes.GraphFrame
import org.apache.spark.sql.DataFrame
import org.apache.spark.sql.types._



object EquiTruss {
  val initialMsg="-10"

  type VertexSet = OpenHashSet[VertexId]

  case class Vert(u:Long,v:Long)

  case class EdgeVert(name:String,count:Int)

  case class NewEdge(edge:EdgeVert,tablet:Map[String,Map[String,Int]])

  def main(args: Array[String]) {


    //    val session = SparkSession.builder().appName("EquiTruss").config("spark.master", "local").getOrCreate()


    val conf = new SparkConf().setAppName("Load graph").setMaster("local")
    val sc = new SparkContext(conf)
    val sqlContext = new org.apache.spark.sql.SQLContext(sc)
    //  import session.sqlContext.implicits._
    import sqlContext.implicits._
    CreateIndex(args, sc)
    sc.stop()
  }



def CreateIndex(args : Array[String], sc : SparkContext){
  val sqlContext = new org.apache.spark.sql.SQLContext(sc)
  import sqlContext.implicits._

  val maxIter = args(1).toInt
    val partitions = args(0).toInt


    val direction: EdgeDirection = EdgeDirection.Either  // In and Out

    val startTimeMillis = System.currentTimeMillis()
    //code here
    val graph= GraphLoader.edgeListFile(sc,args(3), true,partitions,StorageLevel.MEMORY_AND_DISK,StorageLevel.MEMORY_AND_DISK).partitionBy(PartitionStrategy.RandomVertexCut).removeSelfEdges().groupEdges((e1, e2) => e1)

    val modifiedGraph= getTriangle(graph)

    val eMap:Map[String,Map[String,Int]]=Map()
    val mEdges=modifiedGraph.edges  //edge triplets containing the srcAttr, dstAttr and common neighbors
    val edgeCount=mEdges.count()    //number of edges
    val vertCount=modifiedGraph.vertices.count()//number of vertices
  val vertLineGraph:VertexRDD[(Vert,Int,Map[String,Map[String,Int]],Int,VertexSet,(Long,Int),String)]= VertexRDD(mEdges.map(edge=>{(Vert(edge.srcId.toLong, edge.dstId.toLong) , edge.attr._1+2 , eMap , 100000, edge.attr._2,(-1L,999),"")}).zipWithIndex.map(vertex=>{(vertex._2,vertex._1)}))
    //vertex                int                    map   int
    //         ((edge.srcId, edge.dstId), no. of common neighbors or triangles, emap , 100000),edgeID from oringinal graph

    val vertMapping: scala.collection.immutable.Map[Vert,Long]=vertLineGraph.map(vert=>{(vert._2._1 , vert._1)}).collectAsMap.toMap

    val broadCastLookupMap = sc.broadcast(vertMapping)

    val edgeLineGraph = mEdges.flatMap(edge=>{       //iterate through each edge in mEdges
      for(u<-edge.attr._2.iterator) yield            //iterate through the common neighbour set
      {
        if(u<edge.srcId)
        {
          (Vert(edge.srcId.toLong , edge.dstId.toLong), Vert(u.toLong, edge.srcId.toLong), Vert(u.toLong, edge.dstId.toLong))
        }else{
          if(u < edge.dstId)
          {
            (Vert(edge.srcId.toLong , edge.dstId.toLong), Vert(edge.srcId.toLong , u.toLong), Vert(u.toLong , edge.dstId.toLong))
          }else{
            (Vert(edge.srcId.toLong, edge.dstId.toLong) , Vert(edge.srcId.toLong , u.toLong), Vert(edge.dstId.toLong , u.toLong))
          }
        }
      }
    }).flatMap(edge=>{
      List(org.apache.spark.graphx.Edge(broadCastLookupMap.value.get(edge._1).head.toLong,broadCastLookupMap.value.get(edge._2).head.toLong,1L),
        org.apache.spark.graphx.Edge(broadCastLookupMap.value.get(edge._1).head.toLong,broadCastLookupMap.value.get(edge._3).head.toLong,1L),
        org.apache.spark.graphx.Edge(broadCastLookupMap.value.get(edge._2).head.toLong,broadCastLookupMap.value.get(edge._3).head.toLong,1L))
    })
    val lineGraph= Graph(vertLineGraph.repartition(partitions), edgeLineGraph.repartition(partitions), (Vert(0L , 0L) , 2 , eMap , 10000000,new VertexSet, (-1L,999), "") , StorageLevel.MEMORY_AND_DISK ,StorageLevel.MEMORY_AND_DISK).removeSelfEdges().groupEdges((e1, e2) => e1).cache()

    val minGraph = lineGraph.pregel(initialMsg,maxIter,EdgeDirection.Both)(vprogTruss,sendMsgTruss,mergeMsgTruss)


    val ktmax=minGraph.vertices.map(v=>{v._2._2}).max
    val filteredEdge=minGraph.vertices.filter(v=>{v._2._2==ktmax})
    val filteredEdgesCount=filteredEdge.count()
    val filteredVertexCount=filteredEdge.flatMap(v=>{List(v._2._1.u,v._2._1.v)}).distinct.count()
    val GraphwithSuperNodes = minGraph.pregel(initialMsg,5,EdgeDirection.Both)(UpdateForSuperNodes,sendMsgTrussForSuperNodes,mergeMsgTrussForSuperNodes)
    minGraph.edges.map(e=>{e.srcId+"\t"+e.dstId}).repartition(1).saveAsTextFile(args(2)+"/edgeList")
    minGraph.vertices.map(v=>{v._2._1.u+"\t"+v._2._1.v+"\t"+v._2._2}).repartition(1).saveAsTextFile(args(2)+"/edgeList_raw")
    minGraph.vertices.map(v=>{v._1+"\t"+v._2._2}).repartition(1).saveAsTextFile(args(2)+"/mapping")



    val GraphwithSuperEdges = GraphwithSuperNodes.pregel(initialMsg,1,EdgeDirection.Both)(UpdateForSuperEdges,sendMsgTrussForSuperEdges,mergeMsgTrussForSuperEdges)



    val sedg = new mutable.HashSet[Edge[String]]()


    GraphwithSuperEdges.vertices.map(l =>{ l._2._7}).repartition(1).distinct().collect().foreach(k=>{if(k.split("->").size==2) {
      val src = k.split("->")(0); val iter = k.split("->")(1).split("\\|").iterator;  while (iter.hasNext) {val dest = iter.next().toString;
        //if (dest != "" && !(superEdges.contains(Edge(src + "," + dest)) || superEdges.contains(dest + "," + src))) {
        if (dest != "" ) {
          println(src +"   "+dest)
          val s = src.split(",")(0).split("\\(")(1)
          val d = dest.split(",")(0).split("\\(")(1)
          if (!(sedg.contains(Edge(s.toLong ,  d.toLong, "super edge"))  || sedg.contains(Edge(d.toLong ,  s.toLong, "super edge"))))
            sedg += Edge(s.toLong ,  d.toLong, "super edge")}}}})


     val superNodesWithVertices=  GraphwithSuperEdges.vertices.map(k=>{(k._1,((k._2._1.u)),((k._2._1.v)),((k._2._2)),((k._2._6)))})
  val kkk = superNodesWithVertices.map(k=>(k._5,k._2+"|"+k._3+"|"))
  val sss = kkk.reduceByKey((a,b)=>a+b)
  val qqq = sss.map(k=>{(k._1,k._2.toString.split("\\|").distinct)})
  qqq.map(u=>{ var k = ""
    val p = u._2.iterator
    while (p.hasNext){k= k+" "+ p.next().toString}
    (u._1,k) }).repartition(partitions).saveAsTextFile(args(2)+"/superNodesWithVertices")


  val aaa = superNodesWithVertices.map(k=>{ Seq((k._2,k._5.toString()),(k._3,k._5.toString())) }).flatMap(seq => seq).reduceByKey((a,b)=>a+"|"+b+"|")
  val bbb = aaa.map(s=>{(s._1,s._2.split("\\|").distinct)})
  bbb.map(u=>{ var k = ""
    val p = u._2.iterator
    while (p.hasNext){k= k+" "+ p.next().toString}
    (u._1,k) }).repartition(partitions).saveAsTextFile(args(2)+"/VerticesWithNodes")



    val superNodes :VertexRDD[Int]= VertexRDD( GraphwithSuperNodes.vertices.map(l =>{(l._2._6._1 , l._2._6._2)}).repartition(1))
    //    val superNodes :VertexRDD[(Int,Double,String)]= VertexRDD( indexGraph.vertices.map(l =>{(l._2._6._1 , (l._2._6._2,Double.PositiveInfinity,""))}).repartition(1))
    val edgerdddd = sedg.toArray
    val superEdges : RDD[Edge[String]] = sc.parallelize(edgerdddd)
    val superGraph = Graph  (superNodes.repartition(partitions),superEdges.repartition(partitions))
    //   val superGraph = Graph  (superNodes.repartition(partitions),superEdges.repartition(partitions),(0,0,Double.PositiveInfinity,""))
    superGraph.vertices.foreach(println)
    superGraph.edges.foreach(println)

    superGraph.vertices.map(v=>{v._1+" "+v._2}).repartition(1).saveAsTextFile(args(2)+"/superNodes")
    superGraph.edges.map(e=>{e.srcId+" "+e.dstId}).repartition(1).saveAsTextFile(args(2)+"/superEdges")


  val endGraphTimeMillis = System.currentTimeMillis()
    val durationSeconds = (endGraphTimeMillis - startTimeMillis) / 1000
    println("Maximal k-Truss Value : "+ktmax)
    println("Total Execution Time : "+durationSeconds.toString() + "s")
    println("Total Edges Initial : "+edgeCount)
    println("Total Vertices Initial :"+vertCount)
    println("Filtered Edge Count :"+filteredEdgesCount)
    println("Filtered Vertex Count :"+filteredVertexCount)


  }


  def mergeMsgTrussForSuperEdges(msg1: String, msg2:String): String = msg1+":"+msg2 // check message

  def sendMsgTrussForSuperEdges(triplet: EdgeTriplet[(Vert, Int , Map[String,Map[String,Int]] , Int, VertexSet, (Long, Int), String), Long]): Iterator[(VertexId, String)] = {
    val sourceVertex = triplet.srcAttr
    val destVertex=triplet.dstAttr
    if(sourceVertex._2 == destVertex._2 && sourceVertex._6==destVertex._6)
    {
      return Iterator.empty
    }else {
      if (sourceVertex._6._1 < destVertex._6._1) {
        return Iterator((triplet.srcId, sourceVertex._6 + "<-->" + destVertex._6),(triplet.dstId, sourceVertex._6 + "<-->" + destVertex._6))
      }
      else {
        return Iterator((triplet.srcId, destVertex._6 + "<-->" + sourceVertex._6),(triplet.dstId, destVertex._6 + "<-->" + sourceVertex._6))
      }
    }
  }

  def UpdateForSuperEdges(vertexId: VertexId, value: (Vert,Int,Map[String,Map[String,Int]],Int,VertexSet,(Long, Int), String), message: String): (Vert,Int,Map[String,Map[String,Int]],Int,VertexSet,(Long,Int), String) = {
    if (message == initialMsg){
      return (value._1,value._2,value._3,value._4,value._5,value._6,value._7)
    }else{
      var supEdgeset = new OpenHashSet[String]()
      var neighborSuperNodes = value._6.toString+ "->"
      val msg= message.split(":")                                                 // split message by ":"
      for (m <-msg) { // looping through the messages
        var ed = m.split("<-->")
        if (m != "" ){
          if( ed(0)==value._6.toString && !supEdgeset.contains(ed(1))) {
            supEdgeset.add(ed(1))
            neighborSuperNodes += ed(1) + "|"
          }
          else if (ed(1)==value._6.toString && !supEdgeset.contains(ed(0))){
            supEdgeset.add(ed(0))
            neighborSuperNodes+=ed(0)+"|"
          }
        }
        else{
        }
      }

      if(supEdgeset.size==0){
        return (value._1,value._2,value._3,value._4,value._5,value._6,"")
      }
      else{
        return (value._1,value._2,value._3,value._4,value._5,value._6,neighborSuperNodes)
      }
    }
  }




  def sendMsgTrussForSuperNodes(triplet: EdgeTriplet[(Vert, Int , Map[String,Map[String,Int]] , Int, VertexSet, (Long,Int), String), Long]): Iterator[(VertexId, String)] = {
    val sourceVertex = triplet.srcAttr
    val destVertex=triplet.dstAttr
    var map:Map[String,Map[String,Int]] =sourceVertex._3
    var uns=getCoUn(sourceVertex._1.u.toString+","+sourceVertex._1.v.toString , destVertex._1.u.toString+","+destVertex._1.v.toString)._2 //uncommon vertex of source vertex
    var und=getCoUn(destVertex._1.u.toString+","+destVertex._1.v.toString , sourceVertex._1.u.toString+","+sourceVertex._1.v.toString)._2 //uncommon vertex of destination vertex
    var t = sourceVertex._3.get(uns).get(und)



    if(sourceVertex._2 == destVertex._2 && sourceVertex._2 <= t )
    {
      if(sourceVertex._6._1 == -1) {

        return Iterator((triplet.dstId, triplet.srcId + "#"), (triplet.srcId, triplet.dstId + "#" + triplet.srcId + "#"),(triplet.dstId, sourceVertex._2+"truss"),(triplet.srcId, destVertex._2+"truss"))
      }
      else{
        return Iterator((triplet.dstId, sourceVertex._6._1 + "#"), (triplet.srcId, destVertex._6._1 + "#"),(triplet.dstId, sourceVertex._2+"truss"),(triplet.srcId, sourceVertex._2+"truss"))
      }

    }else if(sourceVertex._2 == destVertex._2 && sourceVertex._2 > t ){
      return Iterator((triplet.srcId,triplet.srcId+"#"),(triplet.srcId,sourceVertex._2+"truss"))
    }
    else{
      return Iterator((triplet.srcId,triplet.srcId+"#"),(triplet.srcId,sourceVertex._2+"truss"))
    }
  }



  def mergeMsgTrussForSuperNodes(msg1: String, msg2:String): String = msg1+":"+msg2 // check message

  def UpdateForSuperNodes(vertexId: VertexId, value: (Vert,Int,Map[String,Map[String,Int]],Int,VertexSet,(Long,Int), String), message: String): (Vert,Int,Map[String,Map[String,Int]],Int,VertexSet,(Long, Int), String) = {
    if (message == initialMsg){
      return (value._1,value._2,value._3,value._4,value._5,value._6,value._7)
    }else{
      var supEdgeset = new OpenHashSet[Long]()
      var supNodeset = new mutable.HashSet[Long]()
      var trussnessOfSuperNode = 9999

      val msg= message.split(":")                                                 // split message by ":"
      for (m <-msg) { // looping through the messages
        if (m.split("#")(0) != "" && m.contains("#")){

          if(m.split("#").size==2) {

            if (!supNodeset.contains(m.split("#")(0).toLong)) {
              supNodeset.add(m.split("#")(0).toLong)
            }

            if (!supNodeset.contains(m.split("#")(1).toLong)) {
              supNodeset.add(m.split("#")(1).toLong)
            }
          }
          else if(m.split("#").size==1) {

            if (!supNodeset.contains(m.split("#")(0).toLong)) {
              supNodeset.add(m.split("#")(0).toLong)
            }

          }

        }
        else if (m.split("#")(0)!="" && m.contains("truss")){
          trussnessOfSuperNode = min(m.split("truss")(0).toInt,trussnessOfSuperNode)

        }

      }

      if(supNodeset.size==0){
        return (value._1,value._2,value._3,value._4,value._5,value._6,value._7)
      }else if(supNodeset.size>=1){
        return (value._1,value._2,value._3,value._4,value._5,(supNodeset.min,trussnessOfSuperNode),value._7)
      }
      else{
        return (value._1,value._2,value._3,value._4,value._5,(supNodeset.min,trussnessOfSuperNode),value._7)
      }
    }
  }



  def getCoUn(first:String, second:String):(String,String) ={
    val a = first.split(",")
    val b = second.split(",")
    if(a.contains(b(0)))
    {
      return (b(0), b(1))
    }
    return (b(1) , b(0))
  }

  def mergeMsgTruss(msg1: String, msg2:String): String = msg1+":"+msg2 // check message




  def countTrussness(M:Map[String,Map[String,Int]],k:Int):Int= {
    var count:Array[Int]=new Array[Int](k+1)
    for ((key,v) <- M)
    {
      if (v.size == 2){
        val tr=v.values.toList
        val j = min(k,min(tr(0),tr(1)))
        count(j)=count(j)+1
      }
    }
    for(i<-k to 3 by -1)
    {
      count(i-1)=count(i-1)+count(i)
    }
    var t=k
    while(t>2 && count(t)<t-2)
    {
      t = t-1
    }
    return t
  }

  def sendMsgTruss(triplet: EdgeTriplet[(Vert, Int , Map[String,Map[String,Int]] , Int,VertexSet,(Long, Int),String), Long]): Iterator[(VertexId, String)] = {
    val sourceVertex = triplet.srcAttr
    val destVertex=triplet.dstAttr

    if(sourceVertex._2!=sourceVertex._4 && destVertex._2!=destVertex._4)
    {
      return Iterator((triplet.dstId,sourceVertex._1.u+","+sourceVertex._1.v+"#"+sourceVertex._2),(triplet.srcId,destVertex._1.u+","+destVertex._1.v+"#"+destVertex._2))
    }else if(sourceVertex._2!=sourceVertex._4){
      return Iterator((triplet.dstId,sourceVertex._1.u+","+sourceVertex._1.v+"#"+sourceVertex._2))
    }else if(destVertex._2!=destVertex._4){
      return Iterator((triplet.srcId,destVertex._1.u+","+destVertex._1.v+"#"+destVertex._2))
    }else{
      return Iterator.empty
    }
  }



  def vprogTruss(vertexId: VertexId, value: (Vert,Int,Map[String,Map[String,Int]],Int,VertexSet,(Long, Int),String),message: String): (Vert,Int,Map[String,Map[String,Int]],Int,VertexSet,(Long, Int), String) = {

    if (message == initialMsg){
      return (value._1,value._2,value._3,value._4,value._5,value._6,value._7)
    }else{
      //var tablet:Map[String,Map[String,Int]]= value._3
      var tablet:Map[String,Map[String,Int]] =Map()
      val cTruss=value._2
      val cVert = value._1.u.toString()+","+value._1.v.toString()
      val msg= message.split(":")
      for (m <-msg){
        val (mVert , mTruss) = (m.split("#")(0) , m.split("#")(1).toInt)
        val (co , un) = getCoUn(cVert , mVert)
        if(tablet.contains(un))
        {
          val innerTab = tablet.get(un).head
          if(innerTab.contains(co))
          {
            if(innerTab.get(co).head > mTruss)
            {
              innerTab(co) = mTruss
              tablet(un) = innerTab
            }
          }else
          {
            innerTab += (co -> mTruss)
            tablet(un) = innerTab
          }
        }else{
          val innerTab = Map(co -> mTruss)
          tablet += (un -> innerTab)
        }
      }
      val newTrussness=countTrussness(tablet,cTruss)
      if(newTrussness < cTruss)
      {
        return (value._1,newTrussness,tablet,cTruss,value._5,value._6,value._7)
      }
      return (value._1,value._2,tablet,value._2,value._5,value._6,value._7)
    }
  }




  def getTriangle[VD: ClassTag, ED: ClassTag](graph:Graph[VD, ED]):Graph[VertexSet, (Int,VertexSet)]={

//    var nbrSets: VertexRDD[VertexSet] = graph.collectNeighborIds(EdgeDirection.Either).mapValues { (vid, nbrs) =>  //create sets of vid and their neighbor sets for each vertex

    var nbrSets1 = graph.collectNeighborIds(EdgeDirection.Either)
    println("\n\n\n\n\n\n\n\n before")
      var nbrSets :VertexRDD[VertexSet] = nbrSets1.mapValues { (vid, nbrs) =>  //create sets of vid and their neighbor sets for each vertex
      val set = new VertexSet(nbrs.length)  //create a set of lenght of neighbors of the vertex
    var i = 0
      while (i < nbrs.length) {
        if (nbrs(i) != vid) {     //check if the neighbor vertex is the same as vertex id
          set.add(nbrs(i))        // adding the neighbor vertex to the set of neighbors of vertex
        }
        i += 1
      }
      set
    }



    var setGraph = graph.outerJoinVertices(nbrSets) {       //outer join of vertices of the graph and their neighbor sets
      (vid, _, optSet) => optSet.getOrElse(null)
    }
    val finalGraph= setGraph.mapTriplets(triplet => {       //creating triplets
      val (smallSet, largeSet) = if (triplet.srcAttr.size < triplet.dstAttr.size) {
        (triplet.srcAttr, triplet.dstAttr)
      } else {
        (triplet.dstAttr, triplet.srcAttr)
      }
 val participatingSets = new VertexSet(smallSet.size)
      val iter = smallSet.iterator
      var counter: Int = 0
      while (iter.hasNext) {      //iterating through the smaller neighbor set
        val vid = iter.next()
        if (vid != triplet.srcId && vid != triplet.dstId && largeSet.contains(vid)) {   //Checking if the current vid is in larger neighbor set and is not src or dst of the triplet
          participatingSets.add(vid)  //adding the vid to participatingSets
          counter=counter+1           //counter incremented
        }
      }
      (counter,participatingSets)        //number of common neighbors, set of common neighbors
    })

    finalGraph
  }

}
